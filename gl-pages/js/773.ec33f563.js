(self["webpackChunkpartisia_sdk_docs"]=self["webpackChunkpartisia_sdk_docs"]||[]).push([[773],{1499:(a,t,e)=>{"use strict";e.r(t),e.d(t,{default:()=>O});var n=e(3673),o=e(2323);const s=(0,n.Wm)("div",{class:"text-h6 q-pt-md"},[(0,n.Uk)("Request Signing Raw "),(0,n.Wm)("b",null,"utf8")],-1),i={class:"text-body1"},l=(0,n.Uk)(" After sucessfully "),r=(0,n.Uk)("connecting"),c=(0,n.Uk)(" to a wallet, send over a "),d=(0,n.Wm)("b",null,"utf8",-1),p=(0,n.Uk)(" message to sign "),u={class:"prettyprint break-line"},m={class:"language-javascript"},y=(0,n.Wm)("div",{class:"text-h6 q-pt-md"},"Request Contract Interaction",-1),g=(0,n.Wm)("div",{class:"text-body1"},[(0,n.Uk)(" You will have to build a serialized payload of the contract interaction and send it over as "),(0,n.Wm)("b",null,"hex"),(0,n.Uk)(". Below is an example of a staking MPC. ")],-1),f={class:"prettyprint break-line"},k={class:"language-javascript"},b=(0,n.Wm)("div",{class:"text-body1"}," If you wanted to specify the entire transaction including building the header and inner properties, you could do it like this ",-1),w={class:"prettyprint break-line"},W={class:"language-javascript"},h=(0,n.Wm)("br",null,null,-1);function x(a,t,e,x,v,C){const S=(0,n.up)("router-link"),_=(0,n.up)("q-card-section"),P=(0,n.up)("q-separator"),T=(0,n.up)("q-input"),q=(0,n.up)("q-btn"),U=(0,n.up)("q-card-actions"),B=(0,n.up)("q-card"),M=(0,n.up)("q-page");return(0,n.wg)(),(0,n.j4)(M,{padding:""},{default:(0,n.w5)((()=>[s,(0,n.Wm)("div",i,[l,(0,n.Wm)(S,{to:"connect"},{default:(0,n.w5)((()=>[r])),_:1}),c,d,p]),(0,n.Wm)(B,null,{default:(0,n.w5)((()=>[(0,n.Wm)(_,null,{default:(0,n.w5)((()=>[(0,n.Wm)("div",null,[(0,n.Wm)("pre",u,[(0,n.Wm)("code",m,(0,o.zw)(`const res = await sdk.signMessage({\n  payload: '${x.txtMessage}',\n  payloadType: 'utf8',\n})`),1)])])])),_:1}),(0,n.Wm)(P,{dark:""}),(0,n.Wm)(U,{vertical:""},{default:(0,n.w5)((()=>[(0,n.Wm)(T,{outlined:"",modelValue:x.txtMessage,"onUpdate:modelValue":t[1]||(t[1]=a=>x.txtMessage=a),label:"Text for Wallet to Sign"},null,8,["modelValue"]),(0,n.Wm)(q,{class:"q-mt-sm",color:"primary",label:"Sign Text",onClick:x.onSignUtf8},null,8,["onClick"])])),_:1})])),_:1}),(0,n.Wm)(P,{class:"q-mt-lg",color:"grey",inset:""}),(0,n.Wm)(P,{class:"q-mt-xs",color:"grey",inset:""}),(0,n.Wm)(P,{class:"q-mt-xs",color:"grey",inset:""}),y,g,(0,n.Wm)(B,null,{default:(0,n.w5)((()=>[(0,n.Wm)(_,null,{default:(0,n.w5)((()=>[(0,n.Wm)("div",null,[(0,n.Wm)("pre",f,[(0,n.Wm)("code",k,(0,o.zw)(x.codeExHexPayload),1)])])])),_:1}),(0,n.Wm)(P,{dark:""}),(0,n.Wm)(_,null,{default:(0,n.w5)((()=>[(0,n.Wm)("div",null,[b,(0,n.Wm)("pre",w,[(0,n.Wm)("code",W,(0,o.zw)(x.codeExHex),1)])])])),_:1}),(0,n.Wm)(P,{dark:""}),(0,n.Wm)(U,{vertical:""},{default:(0,n.w5)((()=>[(0,n.Wm)(T,{class:"q-mb-sm",outlined:"",modelValue:x.baseURL,"onUpdate:modelValue":t[2]||(t[2]=a=>x.baseURL=a),label:"Base URL"},null,8,["modelValue"]),h,(0,n.Wm)(T,{class:"q-mt-sm",type:"number",outlined:"",modelValue:x.txtAmount,"onUpdate:modelValue":t[3]||(t[3]=a=>x.txtAmount=a),label:"Amount"},null,8,["modelValue"]),(0,n.Wm)(q,{class:"q-mt-sm",color:"primary",label:"Transfer",onClick:x.onTransfer},null,8,["onClick"])])),_:1})])),_:1})])),_:1})}var v=e(515),C=e.n(v),S=(e(71),e(1959)),_=e(8825),P=(e(3437),e(7874)),T=e(3164),q=e.n(T),U=e(7936),B=(e(568),e(1461)),M=e(19);const R={computed:C()({},(0,P.Se)(["sdkClient"])),setup(){const a=(0,_.Z)(),t=(0,P.oR)(),e=(0,S.iH)("dApp Message"),n=(0,S.iH)("1"),o=(0,S.iH)("https://betareader.partisiablockchain.com/shards/Shard0"),s=`import { partisiaCrypto } from 'partisia-crypto'\nimport { PartisiaRpc } from 'partisia-rpc'\n\n// sdk using connection from before\nconst sdk = new PartisiaSdk({ seed: sdkClient.seed, connection: sdkClient.connection })\n\n// new rpc for communicating directly with nodes\nconst rpc = PartisiaRpc({\n  baseURL: '${o.value}',\n})\n\n// Paramaters\nconst nonce = await rpc.getNonce(sdk.connection.account.address)\nconst contract = '01a4082d9d560749ecd0ffa1dcaaaee2c2cb25d881'\nconst payload = {\n  invocationByte: 0,\n  amount: '${n.value}',\n}\n\n// Build the payload buffer\nconst abi = partisiaCrypto.abi_system.Payload_StakeTokens\nconst dataPayload = partisiaCrypto.structs.serializeToBuffer(payload, ...abi)\n\n// Turn the payload buffer into a fully serialized transaction\nconst serialized = partisiaCrypto.transaction.serializedTransaction(\n  { nonce, validTo: Date.now() + 120 * 1000 }, // two minutes\n  { contract },\n  dataPayload,\n)\n\n// Sign it from the wallet\nconst res = await sdk.signMessage({\n  payload: serialized.toString('hex'),\n  payloadType: 'hex',\n  dontBroadcast: false,\n})`,i="import { partisiaCrypto } from 'partisia-crypto'\n\n// sdk using connection from before\nconst sdk = new PartisiaSdk({ seed: sdkClient.seed, connection: sdkClient.connection })\n\nconst abi = partisiaCrypto.abi_system.Payload_StakeTokens\nconst dataPayload = partisiaCrypto.structs.serializeToBuffer({\n  invocationByte: 0,\n  amount: '10000',\n}, ...abi)\n\n\nconst res = await sdk.signMessage({\n  contract: '01a4082d9d560749ecd0ffa1dcaaaee2c2cb25d881',\n  payload: dataPayload.toString('hex'),\n  payloadType: 'hex_payload',\n  dontBroadcast: false,\n})\nconsole.log('res', JSON.stringify(res, null, 2))\n";return{partisiaCrypto:B.partisiaCrypto,txtAmount:n,txtMessage:e,baseURL:o,codeExHex:s,codeExHexPayload:i,onPayloadOnly:async()=>{},onTransfer:async()=>{try{const e=t.getters.sdkClient,n=new U.Z({seed:e.seed,connection:e.connection}),o=B.partisiaCrypto.abi_system.Payload_StakeTokens,s=B.partisiaCrypto.structs.serializeToBuffer({invocationByte:0,amount:"10000"},...o);M.log("dataPayload",s.toString("hex"));const i=await n.signMessage({contract:"01a4082d9d560749ecd0ffa1dcaaaee2c2cb25d881",payload:s.toString("hex"),payloadType:"hex_payload",dontBroadcast:!1});a.notify({timeout:0,actions:[{icon:"close",color:"white"}],type:"positive",html:!0,position:"top",message:`<pre class="prettyprint break-line"><code class="language-javascript">${JSON.stringify(i,null,2)}</code></pre>`})}catch(e){a.notify({type:"negative",position:"top",message:e.message})}},onSignUtf8:async()=>{try{const n=t.getters.sdkClient;q()(n,"Must connect to a wallet first");const o=new U.Z({seed:n.seed,connection:n.connection}),s=await o.signMessage({payload:e.value,payloadType:"utf8"});M.log("wallet sign:",JSON.stringify(s,null,2)),a.notify({timeout:0,actions:[{icon:"close",color:"white"}],type:"positive",html:!0,position:"top",message:`<pre class="prettyprint break-line"><code class="language-javascript">${JSON.stringify(s,null,2)}</code></pre>`})}catch(n){a.notify({type:"negative",position:"top",message:n.message})}}}},mounted(){setTimeout((()=>{PR.prettyPrint()}),10)}};var z=e(4379),Z=e(151),V=e(5589),A=e(5869),H=e(9367),Q=e(1918),j=e(8240),L=e(9789),N=e.n(L);R.render=x;const O=R;N()(R,"components",{QPage:z.Z,QCard:Z.Z,QCardSection:V.Z,QSeparator:A.Z,QCardActions:H.Z,QInput:Q.Z,QBtn:j.Z})},6601:()=>{},9214:()=>{},1922:()=>{},2363:()=>{},2361:()=>{},4616:()=>{}}]);